<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CacheManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Coverage Report</a> &gt; <a href="index.source.html" class="el_package">models</a> &gt; <span class="el_source">CacheManager.java</span></div><h1>CacheManager.java</h1><pre class="source lang-java linenums">package models;

import models.*;
import play.mvc.*;
import play.libs.ws.*;

import java.util.List;
import java.util.HashMap;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.stream.Collectors;
import play.libs.ws.*;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import Reddit.RedditHelper;
/**
 *  This class is a Singleton class which handles caching of already searched terms
 * @author Saghana Mahesh Sarma
 * @author Sumit Ramesh Bhiungade
 * @author Jai Sahni
 */
@Singleton
public class CacheManager {
<span class="nc" id="L26">  private static CacheManager cache = null;</span>
  private static HashMap&lt;String, QuerySearchResult&gt; results;
  private static HashMap&lt;String, QuerySearchResult&gt; userResults;
  private static HashMap&lt;String, QuerySearchResult&gt; threadResults;
  private static RedditHelper helper;
  /**
   * CacheManager private default Constructor. This initializes the CacheManager object only once
   * @author Saghana Mahesh Sarma
   * @author Sumit Ramesh Bhiungade
   * @author Jai Sahni
   */
  private CacheManager() {
  }
  /**
   * This will be used to get the cache object
   * @author Saghana Mahesh Sarma
   * @author Sumit Ramesh Bhiungade
   * @author Jai Sahni
   * @return The singleton cache object {@link CacheManager}
   * */
  public static CacheManager GetCache(WSClient ws, String endpoint){
<span class="nc bnc" id="L47" title="All 2 branches missed.">    if (cache==null) {</span>
<span class="nc" id="L48">      cache = new CacheManager();</span>
<span class="nc" id="L49">      helper = new RedditHelper(ws, endpoint);</span>
<span class="nc" id="L50">      results = new HashMap&lt;&gt;();</span>
<span class="nc" id="L51">      userResults = new HashMap&lt;&gt;();</span>
<span class="nc" id="L52">      threadResults = new HashMap&lt;&gt;();</span>
    }

<span class="nc" id="L55">    return cache;</span>
  }
 /**
   * This method will return the Trimmed result set for given search term i.e only top 10 results which need to be shown to user. This will first fetch and store the data if it is not already present
   * @author Saghana Mahesh Sarma
   * @author Sumit Ramesh Bhiungade
   * @author Jai Sahni
   * @param keyTerm - The search term for which you want to fetch the result
   * @return The result of type {@link QuerySearchResult} which will contain only 10 results for that search term
   * */
  public CompletableFuture&lt;QuerySearchResult&gt; GetTrimmedSearchResult(String keyTerm){
<span class="nc bnc" id="L66" title="All 2 branches missed.">    if(!results.containsKey(keyTerm)) {</span>
<span class="nc" id="L67">      return AddToCache(keyTerm).thenApply((List&lt;SearchResult&gt; a) -&gt; {</span>
<span class="nc" id="L68">        var returnData = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L69">        returnData.setKeyTermData(results.get(keyTerm).getAllPosts().stream().limit(10).collect(Collectors.toList()));</span>
<span class="nc" id="L70">        returnData.setAnalytics(results.get(keyTerm).getAnalyticsData());</span>
<span class="nc" id="L71">        return returnData;</span>
<span class="nc" id="L72">      }).toCompletableFuture();</span>
    }

<span class="nc" id="L75">    return CompletableFuture.supplyAsync(() -&gt; {</span>
<span class="nc" id="L76">      var returnData = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L77">      returnData.setKeyTermData(results.get(keyTerm).getAllPosts().stream().limit(10).collect(Collectors.toList()));</span>
<span class="nc" id="L78">      returnData.setAnalytics(results.get(keyTerm).getAnalyticsData());</span>
<span class="nc" id="L79">      return returnData;</span>
    });
  }
  /**
   * This method will add search results for a new keyterm to the cache. This will call the PopulateData method of {@link QuerySearchResult}
   * @author Saghana Mahesh Sarma
   * @author Sumit Ramesh Bhiungade
   * @author Jai Sahni
   * @param keyTerm - This is the search term for which we need to add the corresponding result to cache
   * @return {@link SearchResult}
   * */
  private CompletionStage&lt;List&lt;SearchResult&gt;&gt; AddToCache(String keyTerm){
<span class="nc" id="L91">    var result = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L92">    return result.PopulateData(helper).thenApply((List&lt;SearchResult&gt; a) -&gt; {</span>
<span class="nc" id="L93">      results.put(keyTerm, result);</span>
<span class="nc" id="L94">      return a;</span>
    });
  }
 /**
   * This method checks if the subreddit is present in the Hash Data structure already else calls the below method - AddThreadToCache
   to retrieve the information and returns the result
   * @author Jai Sahni
   * @param keyTerm - This is the search term for which we check if it already exists in the HashMap
   * @return {@link QuerySearchResult} object for corresponding subreddit
   *  @return {@link QuerySearchResult}
   * */
  public CompletableFuture&lt;QuerySearchResult&gt; GetThreadInfo(String keyTerm){
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if(!threadResults.containsKey(keyTerm)) {</span>
<span class="nc" id="L107">      return AddThreadToCache(keyTerm).thenApply((List&lt;SearchResult&gt; a) -&gt; {</span>
<span class="nc" id="L108">        var returnData = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L109">        returnData.setKeyTermData(threadResults.get(keyTerm).getAllPosts().stream().limit(10).collect(Collectors.toList()));</span>
<span class="nc" id="L110">        return returnData;</span>
<span class="nc" id="L111">      }).toCompletableFuture();</span>
    }

<span class="nc" id="L114">    return CompletableFuture.supplyAsync(() -&gt; {</span>
<span class="nc" id="L115">      var returnData = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L116">      returnData.setKeyTermData(threadResults.get(keyTerm).getAllPosts().stream().limit(10).collect(Collectors.toList()));</span>
<span class="nc" id="L117">      return returnData;</span>
    });
  }
  /**
   * This method will add subreddit information for a reddit to the cache.
   * @author Jai Sahni
   * @param keyTerm - This is the search term for which we add the corresponding result to cache
   * @return {@link SearchResult}
   * */
  private CompletionStage&lt;List&lt;SearchResult&gt;&gt; AddThreadToCache(String keyTerm){
<span class="nc" id="L127">    var result = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L128">    return result.PopulateThread(helper).thenApply((List&lt;SearchResult&gt; a) -&gt; {</span>
<span class="nc" id="L129">      threadResults.put(keyTerm, result);</span>
<span class="nc" id="L130">      return a;</span>
    });
  }
 /**
   * This method checks if the user Id is present in the Hash Data structure already else calls the below method - AddOwnerInfoToCache
   to retrieve the information and returns the result
   * @author Saghana Mahesh Sarma
   * @param keyTerm - This is the search term for which we check if it already exists in the HashMap
   * @return {@link QuerySearchResult} object for corresponding user
   * */
  public CompletableFuture&lt;QuerySearchResult&gt; GetUserInfo(String keyTerm){
<span class="nc bnc" id="L141" title="All 2 branches missed.">    if(!userResults.containsKey(keyTerm)) {</span>
<span class="nc" id="L142">      return AddUserInfoToCache(keyTerm).thenApply((List&lt;SearchResult&gt; a) -&gt; {</span>
<span class="nc" id="L143">        var returnData = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L144">        returnData.setKeyTermData(userResults.get(keyTerm).getAllPosts().stream().limit(10).collect(Collectors.toList()));</span>
<span class="nc" id="L145">        return returnData;</span>
<span class="nc" id="L146">      }).toCompletableFuture();</span>
    }

<span class="nc" id="L149">    return CompletableFuture.supplyAsync(() -&gt; {</span>
<span class="nc" id="L150">      var returnData = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L151">      returnData.setKeyTermData(userResults.get(keyTerm).getAllPosts().stream().limit(10).collect(Collectors.toList()));</span>
<span class="nc" id="L152">      return returnData;</span>
    });
  }
  /**
   * This method will add user information for a user id to the cache.
   * @author Saghana Mahesh Sarma
   * @param keyTerm - This is the search term for which we add the corresponding result to cache
   * */
  private CompletionStage&lt;List&lt;SearchResult&gt;&gt; AddUserInfoToCache(String keyTerm){
<span class="nc" id="L161">    var result = new QuerySearchResult(keyTerm);</span>
<span class="nc" id="L162">    return result.PopulateUser(helper).thenApply((List&lt;SearchResult&gt; a) -&gt; {</span>
<span class="nc" id="L163">      userResults.put(keyTerm, result);</span>
<span class="nc" id="L164">      return a;</span>
    });
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>